#!btred -NTe nodetypes()
# -*- mode: cperl encoding: utf-8 -*-
use warnings;
use strict;
use experimental qw( signatures );
use utf8;

use List::Util;

sub check($value, $gram, $checked=undef) {
    my %check;
    $check{nodetype} = $value unless $this->{nodetype} eq $value;
    $check{gram} = 'delete' if $gram eq 'delete'
                            && keys %{ $this->{gram} // {} };
    print("Double check $this->{t_lemma} $this->{functor}\t"), FPosition()
        if $checked && (($checked->{nodetype} // "") ne ($check{nodetype} // "")
                        || ($checked->{gram} // "") ne ($check{gram} // ""));
    return \%check
}

my %SET_SEMPOS = (t_lemma => {'#PersPron' => 'n.pron.def.pers',
                              '#EmpNoun'  => 'n.denot'},
                  't_lemma.func' => {'již.TWHEN' => 'adv.denot.ngrad.nneg',
                                     'spíše.EXT' => 'adv.denot.ngrad.nneg',
                                     'ten.PAT'   => 'n.pron.def.demon',
                                     'ten.ACT'   => 'n.pron.def.demon',
                                     'tak.MANN'  => 'adv.denot.ngrad.nneg',
                                     'A.ID'      => 'n.denot'},
                  'pos.func' => {'C.RSTR' => 'adj.quant.def',
                                 'Q.RSTR' => 'adj.denot',
                                 'A.RSTR' => 'adj.denot'},
                  'pos.func.t_lemma' => {
                      'Z.RSTR.procentní' => 'adj.denot',
                      'P.RSTR.ten'       => 'adj.pron.def.demon',
                      'D.LOC.kolem'      => 'adv.denot.ngrad.nneg',
                      'D.DIR2.kolem'     => 'adv.denot.ngrad.nneg',
                      'D.TWHEN.zase'     => 'adv.denot.ngrad.nneg',
                      'T.EXT.asi'        => 'adv.denot.ngrad.nneg',
                      'D.EXT.jak'        => 'adv.denot.ngrad.nneg',
                      'D.MANN.jak'       => 'adv.denot.ngrad.nneg',
                      'D.EXT.tak'        => 'adv.denot.ngrad.nneg',
                      'D.TWHEN.už'       => 'adv.denot.ngrad.nneg',
                      'D.TWHEN.potom'    => 'adv.denot.ngrad.nneg',
                      'D.LOC.tam'        => 'adv.denot.ngrad.nneg',
                      'D.EXT.obzvlášť'   => 'adv.denot.ngrad.nneg',
                      'D.THL.dále'       => 'adv.denot.ngrad.nneg',
                      'D.EXT.hodně'      => 'adv.denot.ngrad.nneg',
                      'D.RSTR.hodně'     => 'adv.denot.ngrad.nneg',
                      'D.LOC.daleko'     => 'adv.denot.ngrad.nneg',
                      'D.DIR3.daleko'    => 'adv.denot.ngrad.nneg',
                      'D.EXT.dále'       => 'adv.denot.ngrad.nneg',
                      'D.DIR3.dále'      => 'adv.denot.ngrad.nneg',
                      'T.EXT.tak'        => 'adv.denot.ngrad.nneg',
                      'N.TWHEN.říjen'    => 'n.denot',
                      'N.CPHR.vliv'      => 'n.denot',}
);

sub nodetypes {
    ChangingFile(0);
    return if $root == $this;

    my $checked;

    if ($this->{functor} =~ /^(?:ATT|CM|INTF|MOD|PARTL|PREC|RHEM)$/) {
        $checked = check('atom', 'delete');

    } elsif ($this->{functor} =~ /^(?:CONJ|ADVS|CSQ|DISJ|GRAD|REAS|CONFR
                                      |CONTRA|OPER|APPS)$/x
    ) {
        $checked = check('coap', 'delete');

    } elsif ($this->{functor} eq 'FPHR') {
        if (my $anode = PML_T::GetALexNode($this)) {
            my $form = $anode->attr('m/form');
            if ($this->{t_lemma} ne $form) {
                print "Fixing FPHR t-lemma $this->{t_lemma} \-> $form\t";
                FPosition();
                ChangingFile(1);
                $this->{t_lemma} = $form;
            }
        } else {
            print "FPHR without a/lexrf\t";
            FPosition();
        }
        $checked = check('fphr', 'delete');

    } elsif ($this->{functor} eq 'DPHR') {
        $checked = check('dphr', 'delete');
    }

    if ($this->{t_lemma} =~ /^#(?:Idph|Forn)$/) {
        $checked = check('list', 'delete', $checked);

    } elsif ($this->{t_lemma} =~ /^\#(?:AsMuch|Benef|Cor|EmpVerb|Equal|Gen
                                        |Oblfm|QCor|Rcp|Some|Total|Unsp)$/x
    ) {
        $checked = check('qcomplex', 'delete', $checked);

    } elsif ($this->{t_lemma} =~ /^\#(?:Amp|Ast|Percnt|Bracket|Comma|Colon
                                        |Dash|Period|Period3|Slash)$/x
         && $this->{functor} !~ /^(?:CONJ|ADVS|CSQ|DISJ|GRAD|REAS|CONFR
                                     |CONTRA|OPER|APPS)$/x
    ) {
        $checked = check('qcomplex', 'delete', $checked);
    }

    if (keys %{ $checked // {}  }) {
        ChangingFile(1);
        delete $this->{gram} if ($checked->{gram} // "") eq 'delete';
        $this->{nodetype} = $checked->{nodetype} if exists $checked->{nodetype};
        print "Fixed\t";
        FPosition();

    } elsif (! defined $checked && $this->{t_lemma} ne '#NewNode') {
        if ($this->{nodetype} ne 'complex') {
            print "$this->{t_lemma}.$this->{functor} \-> complex\t";
            $this->{nodetype} = 'complex';
            ChangingFile(1);
            FPosition();
        }
        unless ($this->attr('gram/sempos')) {
            my $alex = PML_T::GetALexNode($this);
            my $pos = $alex ? substr $alex->attr('m/tag'), 0, 1 : "-";
            my $func = $this->{functor};
            my $tlemma = $this->{t_lemma};
            my @sempos = List::Util::uniq(
                grep defined,
                     $SET_SEMPOS{t_lemma}{$tlemma},
                     $SET_SEMPOS{'t_lemma.func'}{"$tlemma.$func"},
                     $SET_SEMPOS{'pos.func'}{"$pos.$func"},
                     $SET_SEMPOS{'pos.func.t_lemma'}{"$pos.$func.$tlemma"});
            if (@sempos == 1) {
                print "$this->{t_lemma}.$this->{functor}"
                    . "($pos|$this->{nodetype}): $sempos[0]\t";
                ChangingFile(1);
                $this->{gram}{sempos} = $sempos[0];
            } elsif (@sempos) {
                print "Ambiguous: @sempos\t";
            } else {
                print "no sempos: $this->{t_lemma}.$this->{functor}"
                    . "($pos|$this->{nodetype})\t";
            }
            FPosition();
        }
    }
}
