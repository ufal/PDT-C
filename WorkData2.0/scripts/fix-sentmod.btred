#!btred -NTe sentmod()
# -*- encoding: utf-8; mode: cperl -*-
use warnings;
use strict;
use utf8;

my %FUNC; @FUNC{qw{ PRED DENOM PARTL VOCAT PAR ID }} = ();
my %expect;

sub set_sentmod {
    my ($node) = @_;
    if ($node->{is_generated}) {
        $node->{sentmod} //= 'enunc';
        return 'gen'
    }

    my $lex = PML_T::GetALexNode($node);
    my @anodes = PML_T::GetANodes($node);
    if (! $this->{is_generated} && grep $_->attr('m/tag') =~ /^Vi/, @anodes) {
        ChangingFile(1);
        $node->{sentmod} = 'imper';
        return 'imper'

    } elsif (! $lex) {
        $node->{sentmod} = 'enunc';
        return '-'

    } elsif (! $this->{is_generated}) {
        my @ch = $lex->children;
        if (grep $_->attr('m/form') eq '?', @ch) {
            ChangingFile(1);
            $node->{sentmod} = 'inter';
            return 'inter'

        } elsif (grep $_->attr('m/form') eq '!', @ch) {
            ChangingFile(1);
            $node->{sentmod} = 'excl';
            return 'excl'
        }

    }
    ChangingFile(1);
    $node->{sentmod} = 'enunc';
    return 'enunc'
}

sub sentmod {
    if ($this == $root) {
        %expect = ();
        my $aroot = (PML_T::GetANodes($root))[0];
        my @anodes = $aroot->descendants;
        for my $anode (@anodes) {
            ++$expect{inter} if '?' eq $anode->attr('m/form');
            ++$expect{excl}  if '!' eq $anode->attr('m/form');
            ++$expect{imper} if $anode->attr('m/tag') =~ /^Vi/;
            ++$expect{desid}
                if $anode->attr('m/lemma') =~ /^(?:kéž$|nechť-)/
                || $anode->attr('m/lemma') =~ /^ať-/
                    && $anode->{afun} eq 'AuxZ';
        }
        return
    }

    if ($this->{sentmod}) {
        if (! exists $FUNC{ $this->{functor} }) {
            if (! $this->{is_dsp_root}) {
                # Should be a member of is_dsp_root.coap
                if ($this->{is_member}) {
                    my $top = $this->parent;
                    while ($top->{is_member}
                           && 'coap' eq $top->{nodetype}
                           && ! $top->{is_dsp_root}
                    ) {
                        $top = $top->parent;
                    }
                    if (! $top->{is_dsp_root} || 'coap' ne $top->{nodetype}) {
                        print "Deleting: not member of is_dsp_root.coap\t";
                        FPosition();
                        ChangingFile(1);
                        delete $this->{sentmod};
                    }
                } else {
                    print "Deleting: not is_dsp_root\t";
                    FPosition();
                    ChangingFile(1);
                    delete $this->{sentmod};
                }

            }
            if ($this->{nodetype} eq 'coap') {
                print "Deleting: coap should distribute sentmod\t";
                FPosition();
                ChangingFile(1);
                delete $this->{sentmod};
            }
        } else {
            print "Keeping\t";
            FPosition();
        }
    } elsif (exists $FUNC{ $this->{functor} } || $this->{is_dsp_root}) {
        if ('coap' eq $this->{nodetype}) {
            my @ch = PML_T::ExpandCoord($this);
            for my $no_sentmod (grep ! $_->{sentmod}, @ch) {
                print "Setting member ", set_sentmod($no_sentmod), "\t";
                FPosition($no_sentmod);
            }
        } else {
            print "Setting ", set_sentmod($this), ' ',
                   exists $FUNC{ $this->{functor} }
                       ? $this->{functor}
                       : 'dsp',
                   "\t";
            FPosition();
        }
    }

    # Last node in a sentence. Compare set and expected sentmods.
    if (! $this->following) {
        my %set;
        for my $node ($root->descendants) {
            ++$set{ $node->{sentmod} } if $node->{sentmod};
        }
        delete $set{enunc};

        for my $e (keys %expect) {
            next if $expect{$e} == ($set{$e} // 0);

            if (! exists $set{$e}) {
                my $top = $root->firstson;
                if (should_have_sentmod($top)
                    && ($top->{sentmod} // 'enunc') eq 'enunc'
                    && 1 == grep should_have_sentmod($_), $root->descendants
                ) {
                    my $old = $top->{sentmod} // 'empty';
                    ChangingFile(1);
                    $top->{sentmod} = $e;
                    print "Set only candidate $e over $old\t";
                    FPosition($top);
                } elsif ($top->{nodetype} eq 'coap') {
                    my @expanded = grep should_have_sentmod($_),
                                   PML_T::ExpandCoord($top);
                    if (scalar @expanded == grep should_have_sentmod($_),
                                            $root->descendants
                    ) {
                        for my $exp (@expanded) {
                            if (($exp->{sentmod} // 'enunc') eq 'enunc') {
                                my $old = $exp->{sentmod} // 'empty';
                                ChangingFile(1);
                                $exp->{sentmod} = $e;
                                print "Set multi candidate $e over $old\t";
                                FPosition($exp);
                            } else {
                                print "Cannot set multi $e over $exp->{sentmod}\t";
                                FPosition($exp);
                            }
                        }
                    } else {
                        printf "Cannot set full expansion %d != %d\t", scalar @expanded,
                            scalar grep should_have_sentmod($_),
                                        $root->descendants;
                        FPosition($top);
                    }
                } else {
                    unless ($e eq 'excl' && $expect{imper}) {
                        print "Nowhere to set $e: $expect{$e}\t";
                        FPosition();
                    }
                }
            } else {
                unless ($e eq 'excl' && $expect{imper}) {
                    print "Different number $e: $expect{$e} != ", $set{$e} // 0, "\t";
                    FPosition();
                }
            }
        }
        for my $s (keys %set) {
            next if $set{$s} == ($expect{$s} // 0);
            print "Unexpected set $s: $set{$s} != ", $expect{$s} // 0, "\t";
            FPosition();
        }
    }

}

sub should_have_sentmod {
    my ($node) = @_;
    return 1 if exists $FUNC{ $node->{functor} };

    if ($node->{is_dsp_root}) {
        return if 'coap' eq $node->{nodetype};

        return 1
    }
    return unless $node->{is_member};

    my $top = $node->parent;
    while ($top->{is_member}
           && 'coap' eq $top->{nodetype}
           && ! $top->{is_dsp_root}
    ) {
        $top = $top->parent;
    }
    return 1 if $top->{is_dsp_root} && 'coap' eq $top->{nodetype};

    return
}
