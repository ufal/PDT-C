#!btred -Te subf()
# -*- mode: cperl; encoding: utf-8; -*-
use warnings;
use strict;
use utf8;

my $ADVERBIAL = '^(?:ACMP|REG|MANN|MEANS|TPAR|TWHEN|LOC|MOD|RESL|ATT|CAUS'
              . '|COND|DIR3|AIM|INTT|EXT|THO|CRIT|RESTR|CNCS|CPR)$';

sub has_aux_s7 {
    my ($node) = @_;
    my @anodes = PML_T::GetAAuxNodes($node);
    return $anodes[0] if 1 == @anodes
                      && 's-1' eq $anodes[0]->attr('m/lemma')
                      && $anodes[0]->attr('m/tag') =~ /^R[RV]--7/;
}

sub formated {
    my ($tag, $anode) = @_;
    "<<$tag:" . $anode->attr('m/form') . '>>'
}

sub subf {
    my ($atree) = PML_T::GetANodes($root);
    return if $atree->descendants <= 4;

    for my $verb (grep 'v' eq ($_->attr('gram/sempos') // "")
                       && ! $_->{is_generated},
                  $root->descendants
    ) {
        next if $verb->{t_lemma} =~ /^bý(?:(?:vá)?va)?t$/;

        my @adv = grep $_->{functor} =~ /$ADVERBIAL/
                       && ! $_->{is_generated}
                       && has_aux_s7($_),
                  PML_T::GetEChildren($verb);

        if (1 == @adv) {
            my $averb = $verb->attr('a/lex.rf');
            next unless $averb;

            my $aadv = $adv[0]->attr('a/lex.rf');
            next unless $aadv;

            my $aprep = has_aux_s7($adv[0]);

            for my $anode (
                sort { $a->{ord} <=> $b->{ord} } $atree->descendants
            ) {
                my $func = $adv[0]->{functor};
                print
                      "a#$anode->{id}" eq $averb ? formated('verb', $anode)
                    : "a#$anode->{id}" eq $aadv  ? formated("f%$func", $anode)
                    : $anode == $aprep           ? formated('prep', $anode)
                                                 : $anode->attr('m/form');
                print ' ';
            }
            print "\t";
            FPosition($verb);
        }
    }
}
