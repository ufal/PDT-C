#!btred -Te subf()
# -*- mode: cperl; encoding: utf-8; -*-
use warnings;
use strict;
use utf8;

my $ADVERBIAL = '^(?:ACMP|REG|MANN|MEANS|TPAR|TWHEN|LOC|MOD|RESL|ATT|CAUS'
              . '|COND|DIR3|AIM|INTT|EXT|THO|CRIT|RESTR|CNCS|CPR)$';

sub has_aux_s7 {
    my ($node) = @_;
    my @anodes = PML_T::GetAAuxNodes($node);
    return 1 == @anodes
           && 's-1' eq $anodes[0]->attr('m/lemma')
           && $anodes[0]->attr('m/tag') =~ /^R[RV]--7/
}

sub subf {
    my ($atree) = PML_T::GetANodes($root);
    return if $atree->descendants <= 4;

    for my $verb (grep 'v' eq ($_->attr('gram/sempos') // "")
                       && ! $_->{is_generated},
                  $root->descendants
    ) {
        next if $verb->{t_lemma} =~ /^bý(?:(?:vá)?va)?t$/;

        my @adv = grep $_->{functor} =~ /$ADVERBIAL/
                       && ! $_->{is_generated}
                       && has_aux_s7($_),
                  PML_T::GetEChildren($verb);

        if (1 == @adv) {
            my $averb = $verb->attr('a/lex.rf');
            next unless $averb;

            my $aadv = $adv[0]->attr('a/lex.rf');
            next unless $aadv;

            for my $anode (
                sort { $a->{ord} <=> $b->{ord} } $atree->descendants
            ) {
                print
                    "a#$anode->{id}" eq $averb
                                      ? '<<<' . ($anode->attr('m/form')) . '>>>'
                    : "a#$anode->{id}" eq $aadv
                                      ? "[[[$adv[0]->{functor}:" . ($anode->attr('m/form')) . ']]]'
                                      : $anode->attr('m/form');
                print ' ';
            }
            print "\t";
            FPosition($verb);
        }
    }
}
