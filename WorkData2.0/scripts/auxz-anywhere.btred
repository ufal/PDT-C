#!btred -TNe triples()
# -*- mode: cperl; -*-
use warnings;
use strict;

# $the input file is the output of
#   btred -I auxz-lf.btred | cut -f2 | sort -u

sub lemma_prefix {
    my ($lemma) = @_;
    $lemma =~ s/(?<=.)[-_`].*//r
}

my %lemma;
open my $in, '<', 'auxz-lemma.l' or die $!;
while (<$in>) {
    chomp;
    undef $lemma{ lemma_prefix($_) };
}

sub report {
    my ($type, $anode) = @_;
    print(join "\t", $type,
                     PML_A_Compat::attr($anode, 'm/form'),
                     PML_A_Compat::attr($anode, 'm/lemma'),
                     PML_A_Compat::attr($anode, 'm/tag'),
                     $anode->{afun},
                     $this->{functor},
                     ""
    );
    FPosition();
}

sub triples {
    return if $this == $root;

    if ($this->attr('a/lex.rf')) {
        my $anode = PML_T::GetALexNode($this);
        my $mlemma = lemma_prefix(PML_A_Compat::attr($anode, 'm/lemma'));
        return unless exists $lemma{$mlemma};

        report(lex => $anode);
    }

    if ($this->attr('a/aux.rf')) {
        my @anodes = grep {
            my $mlemma = lemma_prefix(PML_A_Compat::attr($_, 'm/lemma'));
            exists $lemma{$mlemma}
        } PML_T::GetAAuxNodes($this);
        report(aux => $_) for @anodes;
    }
}
