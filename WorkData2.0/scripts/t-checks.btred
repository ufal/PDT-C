#!btred -NTe t_checks()
# -*- mode: cperl; encoding: utf-8 -*-
use warnings;
use strict;

use feature 'say';
my @CHECKS = (
    [{functor => 'FPHR'}, {nodetype => 'fphr'}],
    [{nodetype => 'fphr'}, {functor => 'FPHR'}],
    [{functor => 'DPHR'}, {nodetype => 'dphr'}],
    [{nodetype => 'dphr'}, {functor => 'DPHR'}],
    [{functor => '(?:ATT|CM|INTF|MOD|PARTL|PREC|RHEM)$'}, {nodetype => 'atom'}],
    [{nodetype => 'atom'}, {functor => '(?:ATT|CM|INTF|MOD|PARTL|PREC|RHEM)$'}],
    [{functor => '(?:CONJ|ADVS|CSQ|DISJ|GRAD|REAS|CONFR|CONTRA|OPER|APPS)$'},
     {nodetype => 'coap'}],
    [{nodetype => 'coap'},
     {functor => '(?:CONJ|ADVS|CSQ|DISJ|GRAD|REAS|CONFR|CONTRA|OPER|APPS)$'}],
    [{t_lemma => '#(?:Idph|Forn)$'}, {nodetype => 'list'}],
    [{nodetype => 'list'}, {t_lemma => '#(?:Idph|Forn)$'}],
    [{t_lemma => '#(?:Cor|EmpVerb|Equal|Gen|Oblfm|QCor|Rcp|Some|Total|Unsp)$'},
     {nodetype => 'qcomplex'}],
    [{nodetype => 'qcomplex'},
     {t_lemma => '#(?:Cor|EmpVerb|Equal|Gen|Oblfm|QCor|Rcp|Some|Total|Unsp|Amp|Ast|Benef|AsMuch|Percnt|Bracket|Comma|Colon|Dash|Period|Period3|Slash)$'},
     functor => '(?!(?:CONJ|ADVS|CSQ|DISJ|GRAD|REAS|CONFR|CONTRA|OPER|APPS)$)'],
    [{t_lemma => '#(?:Amp|Ast|Benef|AsMuch|Percnt|Bracket|Comma|Colon|Dash|Period|Period3|Slash)$',
      functor => '(?!(?:CONJ|ADVS|CSQ|DISJ|GRAD|REAS|CONFR|CONTRA|OPER|APPS)$)'},
     {nodetype => 'qcomplex'}],
    [{nodetype => '(?!complex$)'}, sub {
         say "Only complex nodes have grammatemes\t", ThisAddress($this)
             if $this->{gram};
     }],
    [{gram => ''}, {nodetype => '(?!complex$)'}],
    [{functor => '(?:ATT|DPHR|FPHR|INTF)$'}, \&tlemma_eq_form],
    [{'gram/sempos' => 'v'}, {'val_frame.rf' => '(?:v#.*)'}],
    [{'val_frame.rf' => '(?:v#)'}, {'gram/sempos' => '(?:n.*|v|ad[jv].*)'}]);


sub t_checks {
    return if $root == $this;

  CHECK1:
    for my $check (@CHECKS) {
        my ($condition, $verify) = @$check;
        for my $attr (keys %$condition) {
            my $value = $condition->{$attr};
            if ($value =~ /\(/) {
                next CHECK1 unless ($this->attr($attr) // "") =~ /^$value/;
            } else {
                next CHECK1 unless $value eq ($this->attr($attr) // "");
            }
        }
        if ('CODE' eq ref $verify) {
            $verify->();
        } else {
            for my $v_attr (keys %$verify) {
                my $value = $verify->{$v_attr};
                if ($value =~ /\(/) {
                    my $attr_value = $this->attr($v_attr) // "";
                    say "Invalid $v_attr=$attr_value\t", ThisAddress($this)
                        unless $attr_value =~ /^$value/;
                } else {
                    say "Invalid $v_attr=$this->{$v_attr}($value)\t",
                        ThisAddress($this)
                        unless $this->{$v_attr} eq $value;
                }
            }
        }
    }
}

sub tlemma_eq_form {
    my $lex = $this->attr('a/lex.rf') ? PML_T::GetALexNode($this) : undef;
    my $should_keep_case = $this->{functor} eq 'FPHR';
    if (! $lex) {
        print "$this->{functor} without a/lex\t";
        FPosition($this);
         return
     }
    my @aux = PML_T::GetAAuxNodes($this);
    my $form = join '_',
               map $should_keep_case           ? $_->[2]
                   : $_->[1] =~ /^[[:upper:]]/ ? ucfirst lc $_->[2]
                                               : lc $_->[2],
               sort { $a->[0] <=> $b->[0] }
               map [$_->{ord}, $_->attr('m/lemma'), $_->attr('m/form')],
               grep defined,
               @aux, $lex;
    say "$this->{functor} tlemma ne mform\t",
        "$this->{t_lemma}=$form\t",
        ThisAddress($this)
        if $this->{t_lemma} ne $form;
 }
