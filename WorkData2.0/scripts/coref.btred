#!btred -e coref()
# -*- mode: cperl; encoding: utf-8; -*-
use warnings;
use strict;
use utf8;

# Finds gram, text, and compl arrows with missing targets and similar
# problems.

sub gram_must {
    my ($node) = @_;
    return 1 if $node->{t_lemma} =~ /^(?:#Q?Cor)$/;
    return 1 if $node->{t_lemma} =~ /^#(?:Rcp|PersPron)$/
        && $node->{functor} ne 'DPHR'
        && $node->attr('a/lex.rf')
        && PML_T::GetALexNode($node)->attr('m/lemma')
            =~ m{^(?:se_\^\(zvr\._zájmeno/částice\)|svůj-1)$};
    if ($node->{t_lemma} =~ /^(?:který(?:žto)?
                             |(?:od|do)kdy
                             |ku?dy|jaký|čí|kde|odkud|kam|jak|jenž)$/x
    ) {
        my @p = $node;
        @p = map PML_T::GetEParents($_), @p
            until ! @p || grep 'v' eq ($_->attr('gram/sempos') // ""), @p;
        if (@p && grep 'RSTR' eq $_->{functor}, @p) {
            return 1
        }
    }
    return
}

my $GRAM_CAN = '^(?:#(?:PersPron|Q?Cor|Rcp)|j(?:enž|aký?)|což?|k(?:d[oy]|de|am|terý))$';

sub coref {
    my @trees;
    my %id;
    do {{
        push @trees, $this;
        while ($this = $this->following) {
            $id{ $this->{id} } = $this->root->{id};
        }
    }} while TredMacro::NextTree();

    for my $tree (@trees) {
        for my $node ($tree->descendants) {
             if ($node->{'compl.rf'}) {
                 if ('COMPL' ne $node->{functor}) {
                     print "not COMPL\t";
                     FPosition($node);
                 }
                 for my $rf (ListV($node->{'compl.rf'})) {
                     if (! exists $id{$rf}) {
                         print "no compl target\t";
                         FPosition($node);
                     } elsif ($id{$rf} ne $node->root->{id}) {
                         print "compl difftree\t";
                         FPosition($node);
                     }
                 }
             } elsif ('COMPL' eq $node->{functor}) {
                 print "missing rf\t";
                 FPosition($node);
             }

             if (my @rf = ListV($node->{'coref_gram.rf'})) {
                 if ($node->{t_lemma} !~ $GRAM_CAN && ! gram_must($node)) {
                     print "$node->{t_lemma} with gram\t";
                     FPosition($node);
                 }
                 for my $rf (@rf) {
                     if (! exists $id{$rf}) {
                         print "no gram target\t";
                         FPosition($node);
                     } elsif ($id{$rf} ne $node->root->{id}) {
                         print "$node->{t_lemma} gram difftree\t";
                         FPosition($node);
                     }
                 }
             } elsif (gram_must($node)) {
                 print "$node->{t_lemma} without gram\t";
                 FPosition($node);
             }

             if (my @rf = ListV($node->{'coref_text'})) {
                 for my $rf (map $_->{'target_node.rf'}, @rf) {
                     if (! exists $id{$rf}) {
                         print "no text target\t";
                         FPosition($node);
                     }
                 }
             }

             if (my @bridging = ListV($node->{bridging})) {
                 for my $rf (map $_->{'target_node.rf'}, @bridging) {
                     if (! exists $id{$rf}) {
                         print "no bridging target\t";
                         FPosition($node);
                     }
                 }
             }

             if ('#PersPron' eq $node->{t_lemma}) {
                 if ('DPHR' eq $node->{functor}) {
                     print "DPHR #perspron\t";
                     FPosition($node);
                 }
                 if (! $node->{coref_text}
                     && ! $node->{'coref_gram.rf'}
                     && ! $node->{coref_special}
                     && ! $node->{bridging}
                 ) {
                     print "no coref type\t";
                     FPosition($node);
                 }
             }

             if ($node->attr('a/lex.rf')) {
                 my $anode = PML_T::GetALexNode($node);
                 if ($anode->attr('m/lemma')
                     =~ m{^s(?:e_\^\(zvr\._zájmeno/částice\)|vůj-1)}
                 ) {
                     if ('DPHR' ne $node->{functor}
                         && $node->{t_lemma} !~ /^#(?:PersPron|Rcp)$/
                     ) {
                         print "$node->{t_lemma} not DPHR\t";
                         FPosition($node);
                     }
                 }
             }
         }
    }
}
